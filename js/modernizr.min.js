/*!
 * modernizr v3.5.0
 * Build https://modernizr.com/download?-flexbox-objectfit-addtest-fnbind-printshiv-testprop-dontmin
 *
 * Copyright (c)
 *  Faruk Ates
 *  Paul Irish
 *  Alex Sexton
 *  Ryan Seddon
 *  Patrick Kettner
 *  Stu Cox
 *  Richard Herrera

 * MIT License
 */
/*
 * Modernizr tests which native CSS3 and HTML5 features are available in the
 * current UA and makes the results available to you in two ways: as properties on
 * a global `Modernizr` object, and as classes on the `<html>` element. This
 * information allows you to progressively enhance your pages with a granular level
 * of control over the experience.
*/
!function(e,t,n){/**
   * is returns a boolean if the typeof an obj is exactly type.
   *
   * @access private
   * @function is
   * @param {*} obj - A thing we want to check the type of
   * @param {string} type - A string to compare the typeof against
   * @returns {boolean}
   */
function r(e,t){return typeof e===t}/**
   * addTest allows you to define your own feature detects that are not currently
   * included in Modernizr (under the covers it's the exact same code Modernizr
   * uses for its own [feature detections](https://github.com/Modernizr/Modernizr/tree/master/feature-detects)). Just like the offical detects, the result
   * will be added onto the Modernizr object, as well as an appropriate className set on
   * the html element when configured to do so
   *
   * @memberof Modernizr
   * @name Modernizr.addTest
   * @optionName Modernizr.addTest()
   * @optionProp addTest
   * @access public
   * @function addTest
   * @param {string|object} feature - The string name of the feature detect, or an
   * object of feature detect names and test
   * @param {function|boolean} test - Function returning true if feature is supported,
   * false if not. Otherwise a boolean representing the results of a feature detection
   * @example
   *
   * The most common way of creating your own feature detects is by calling
   * `Modernizr.addTest` with a string (preferably just lowercase, without any
   * punctuation), and a function you want executed that will return a boolean result
   *
   * ```js
   * Modernizr.addTest('itsTuesday', function() {
   *  var d = new Date();
   *  return d.getDay() === 2;
   * });
   * ```
   *
   * When the above is run, it will set Modernizr.itstuesday to `true` when it is tuesday,
   * and to `false` every other day of the week. One thing to notice is that the names of
   * feature detect functions are always lowercased when added to the Modernizr object. That
   * means that `Modernizr.itsTuesday` will not exist, but `Modernizr.itstuesday` will.
   *
   *
   *  Since we only look at the returned value from any feature detection function,
   *  you do not need to actually use a function. For simple detections, just passing
   *  in a statement that will return a boolean value works just fine.
   *
   * ```js
   * Modernizr.addTest('hasJquery', 'jQuery' in window);
   * ```
   *
   * Just like before, when the above runs `Modernizr.hasjquery` will be true if
   * jQuery has been included on the page. Not using a function saves a small amount
   * of overhead for the browser, as well as making your code much more readable.
   *
   * Finally, you also have the ability to pass in an object of feature names and
   * their tests. This is handy if you want to add multiple detections in one go.
   * The keys should always be a string, and the value can be either a boolean or
   * function that returns a boolean.
   *
   * ```js
   * var detects = {
   *  'hasjquery': 'jQuery' in window,
   *  'itstuesday': function() {
   *    var d = new Date();
   *    return d.getDay() === 2;
   *  }
   * }
   *
   * Modernizr.addTest(detects);
   * ```
   *
   * There is really no difference between the first methods and this one, it is
   * just a convenience to let you write more readable code.
   */
function o(e,t){if("object"==typeof e)for(var n in e)y(e,n)&&o(n,e[n]);else{var r=(e=e.toLowerCase()).split("."),i=g[r[0]];if(
// Again, we don't check for parent test existence. Get that right, though.
2==r.length&&(i=i[r[1]]),void 0!==i)
// we're going to quit if you're trying to overwrite an existing test
// if we were to allow it, we'd do this:
//   var re = new RegExp("\\b(no-)?" + feature + "\\b");
//   docElement.className = docElement.className.replace( re, '' );
// but, no rly, stuff 'em.
return g;t="function"==typeof t?t():t,
// Set the value (this is the magic, right here).
1==r.length?g[r[0]]=t:(
// cast to a Boolean, if not one already
!g[r[0]]||g[r[0]]instanceof Boolean||(g[r[0]]=new Boolean(g[r[0]])),g[r[0]][r[1]]=t),
// Set a single class (either `feature` or `no-feature`)
/**
   * setClasses takes an array of class names and adds them to the root element
   *
   * @access private
   * @function setClasses
   * @param {string[]} classes - Array of class names
   */
// Pass in an and array of class names, e.g.:
//  ['no-webp', 'borderradius', ...]
function(e){var t=C.className,n=g._config.classPrefix||"";
// Change `no-js` to `js` (independently of the `enableClasses` option)
// Handle classPrefix on this too
if(b&&(t=t.baseVal),g._config.enableJSClass){var r=new RegExp("(^|\\s)"+n+"no-js(\\s|$)");t=t.replace(r,"$1"+n+"js$2")}g._config.enableClasses&&(
// Add the new classes
t+=" "+n+e.join(" "+n),b?C.className.baseVal=t:C.className=t)}([(t&&0!=t?"":"no-")+r.join("-")]),
// Trigger the event
g._trigger(e,t)}return g}/**
   * contains checks to see if a string contains another string
   *
   * @access private
   * @function contains
   * @param {string} str - The string we want to check for substrings
   * @param {string} substr - The substring we want to search the first string for
   * @returns {boolean}
   */
function i(e,t){return!!~(""+e).indexOf(t)}/**
   * createElement is a convenience wrapper around document.createElement. Since we
   * use createElement all over the place, this allows for (slightly) smaller code
   * as well as abstracting away issues with creating elements in contexts other than
   * HTML documents (e.g. SVG documents).
   *
   * @access private
   * @function createElement
   * @returns {HTMLElement|SVGElement} An HTML or SVG element
   */
function a(){return"function"!=typeof t.createElement?t.createElement(arguments[0]):b?t.createElementNS.call(t,"http://www.w3.org/2000/svg",arguments[0]):t.createElement.apply(t,arguments)}/**
   * injectElementWithStyles injects an element with style element and some CSS rules
   *
   * @access private
   * @function injectElementWithStyles
   * @param {string} rule - String representing a css rule
   * @param {function} callback - A function that is used to test the injected element
   * @param {number} [nodes] - An integer representing the number of additional nodes you want injected
   * @param {string[]} [testnames] - An array of strings that are used as ids for the additional nodes
   * @returns {boolean}
   */
function s(e,n,r,o){var i,s,l,u,c=a("div"),f=/**
   * getBody returns the body of a document, or an element that can stand in for
   * the body if a real body does not exist
   *
   * @access private
   * @function getBody
   * @returns {HTMLElement|SVGElement} Returns the real body of a document, or an
   * artificially created element that stands in for the body
   */
function(){
// After page load injecting a fake body doesn't work so check if body exists
var e=t.body;
// Can't use the real body create a fake one.
return e||((e=a(b?"svg":"body")).fake=!0),e}();if(parseInt(r,10))
// In order not to give false positives we create a node for each test
// This also allows the method to scale for unspecified uses
for(;r--;)(l=a("div")).id=o?o[r]:"modernizr"+(r+1),c.appendChild(l);
// IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
// Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
//avoid crashing IE8, if background image is used
//Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
// If this is done after page load we don't want to remove the body so check if body exists
// Trigger layout so kinetic scrolling isn't disabled in iOS6+
// eslint-disable-next-line
return i=a("style"),i.type="text/css",i.id="smodernizr",(f.fake?f:c).appendChild(i),f.appendChild(c),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(t.createTextNode(e)),c.id="modernizr",f.fake&&(f.style.background="",f.style.overflow="hidden",u=C.style.overflow,C.style.overflow="hidden",C.appendChild(f)),s=n(c,e),f.fake?(f.parentNode.removeChild(f),C.style.overflow=u,C.offsetHeight):c.parentNode.removeChild(c),!!s}/**
   * domToCSS takes a camelCase string and converts it to kebab-case
   * e.g. boxSizing -> box-sizing
   *
   * @access private
   * @function domToCSS
   * @param {string} name - String name of camelCase prop we want to convert
   * @returns {string} The kebab-case version of the supplied name
   */
function l(e){return e.replace(/([A-Z])/g,function(e,t){return"-"+t.toLowerCase()}).replace(/^ms-/,"-ms-")}/**
   * nativeTestProps allows for us to use native feature detection functionality if available.
   * some prefixed form, or false, in the case of an unsupported rule
   *
   * @access private
   * @function nativeTestProps
   * @param {array} props - An array of property names
   * @param {string} value - A string representing the value we want to check via @supports
   * @returns {boolean|undefined} A boolean when @supports exists, undefined otherwise
   */
// Accepts a list of property names and a single value
// Returns `undefined` if native detection not available
function u(t,r){var o=t.length;
// Start with the JS API: http://www.w3.org/TR/css3-conditional/#the-css-interface
if("CSS"in e&&"supports"in e.CSS){
// Try every prefixed variant of the property
for(;o--;)if(e.CSS.supports(l(t[o]),r))return!0;return!1}if("CSSSupportsRule"in e){for(
// Build a condition string for every prefixed variant
var i=[];o--;)i.push("("+l(t[o])+":"+r+")");return i=i.join(" or "),s("@supports ("+i+") { #modernizr { position: absolute; } }",function(t){/**
   * wrapper around getComputedStyle, to fix issues with Firefox returning null when
   * called inside of a hidden iframe
   *
   * @access private
   * @function computedStyle
   * @param {HTMLElement|SVGElement} - The element we want to find the computed styles of
   * @param {string|null} [pseudoSelector]- An optional pseudo element selector (e.g. :before), of null if none
   * @returns {CSSStyleDeclaration}
   */
return"absolute"==function(t,n,r){var o;if("getComputedStyle"in e){o=getComputedStyle.call(e,t,n);var i=e.console;null!==o?r&&(o=o.getPropertyValue(r)):i&&i[i.error?"error":"log"].call(i,"getComputedStyle returning null, its possible modernizr test results are inaccurate")}else o=!n&&t.currentStyle&&t.currentStyle[r];return o}(t,null,"position")})}return n}/**
   * cssToDOM takes a kebab-case string and converts it to camelCase
   * e.g. box-sizing -> boxSizing
   *
   * @access private
   * @function cssToDOM
   * @param {string} name - String name of kebab-case prop we want to convert
   * @returns {string} The camelCase version of the supplied name
   */
function c(e){return e.replace(/([a-z])-([a-z])/g,function(e,t,n){return t+n.toUpperCase()}).replace(/^-/,"")}
// testProps is a generic CSS / DOM property test.
// In testing support for a given CSS property, it's legit to test:
//    `elem.style[styleName] !== undefined`
// If the property is supported it will return an empty string,
// if unsupported it will return undefined.
// We'll take advantage of this quick test and skip setting a style
// on our modernizr element, but instead just testing undefined vs
// empty string.
// Property names can be provided in either camelCase or kebab-case.
function f(e,t,o,s){
// Delete the objects if we created them.
function l(){d&&(delete x.style,delete x.modElem)}
// Try native detect first
if(s=!r(s,"undefined")&&s,!r(o,"undefined")){var f=u(e,o);if(!r(f,"undefined"))return f}for(
// Otherwise do it properly
var d,p,m,h,v,g=["modernizr","tspan","samp"];!x.style&&g.length;)d=!0,x.modElem=a(g.shift()),x.style=x.modElem.style;for(m=e.length,p=0;p<m;p++)if(h=e[p],v=x.style[h],i(h,"-")&&(h=c(h)),x.style[h]!==n){
// If value to test has been passed in, do a set-and-check test.
// 0 (integer) is a valid property value, so check that `value` isn't
// undefined, rather than just checking it's truthy.
if(s||r(o,"undefined"))return l(),"pfx"!=t||h;
// Needs a try catch block because of old IE. This is slow, but will
// be avoided in most cases because `skipValueTest` will be used.
try{x.style[h]=o}catch(e){}
// If the property value has changed, we assume the value used is
// supported. If `value` is empty string, it'll fail here (because
// it hasn't changed), which matches how browsers have implemented
// CSS.supports()
if(x.style[h]!=v)return l(),"pfx"!=t||h}return l(),!1}/**
   * fnBind is a super small [bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) polyfill.
   *
   * @access private
   * @function fnBind
   * @param {function} fn - a function you want to change `this` reference to
   * @param {object} that - the `this` you want to call the function with
   * @returns {function} The wrapped version of the supplied function
   */
function d(e,t){return function(){return e.apply(t,arguments)}}/**
   * testPropsAll tests a list of DOM properties we want to check against.
   * We specify literally ALL possible (known and/or likely) properties on
   * the element including the non-vendor prefixed one, for forward-
   * compatibility.
   *
   * @access private
   * @function testPropsAll
   * @param {string} prop - A string of the property to test for
   * @param {string|object} [prefixed] - An object to check the prefixed properties on. Use a string to skip
   * @param {HTMLElement|SVGElement} [elem] - An element used to test the property and value against
   * @param {string} [value] - A string of a css value
   * @param {boolean} [skipValueTest] - An boolean representing if you want to test if value sticks when set
   * @returns {false|string} returns the string version of the property, or false if it is unsupported
   */
function p(e,t,n,o,i){var a=e.charAt(0).toUpperCase()+e.slice(1),s=(e+" "+_.join(a+" ")+a).split(" ");
// did they call .prefixed('boxSizing') or are we just testing a prop?
// did they call .prefixed('boxSizing') or are we just testing a prop?
/**
   * testDOMProps is a generic DOM property test; if a browser supports
   *   a certain property, it won't return undefined for it.
   *
   * @access private
   * @function testDOMProps
   * @param {array.<string>} props - An array of properties to test for
   * @param {object} obj - An object or Element you want to use to test the parameters again
   * @param {boolean|object} elem - An Element to bind the property lookup again. Use `false` to prevent the check
   * @returns {false|*} returns false if the prop is unsupported, otherwise the value that is supported
   */
return r(t,"string")||r(t,"undefined")?f(s,t,o,i):(s=(e+" "+w.join(a+" ")+a).split(" "),function(e,t,n){var o;for(var i in e)if(e[i]in t)
// return the property name as a string
// return the property name as a string
// let's bind a function
return!1===n?e[i]:(o=t[e[i]],r(o,"function")?d(o,n||t):o);return!1}(s,t,n))}/**
   * testAllProps determines whether a given CSS property is supported in the browser
   *
   * @memberof Modernizr
   * @name Modernizr.testAllProps
   * @optionName Modernizr.testAllProps()
   * @optionProp testAllProps
   * @access public
   * @function testAllProps
   * @param {string} prop - String naming the property to test (either camelCase or kebab-case)
   * @param {string} [value] - String of the value to test
   * @param {boolean} [skipValueTest=false] - Whether to skip testing that the value is supported when using non-native detection
   * @example
   *
   * testAllProps determines whether a given CSS property, in some prefixed form,
   * is supported by the browser.
   *
   * ```js
   * testAllProps('boxSizing')  // true
   * ```
   *
   * It can optionally be given a CSS value in string form to test if a property
   * value is valid
   *
   * ```js
   * testAllProps('display', 'block') // true
   * testAllProps('display', 'penguin') // false
   * ```
   *
   * A boolean can be passed as a third parameter to skip the value check when
   * native detection (@supports) isn't available.
   *
   * ```js
   * testAllProps('shapeOutside', 'content-box', true);
   * ```
   */
function m(e,t,r){return p(e,n,n,t,r)}var h=[],v={
// The current version, dummy
_version:"3.5.0",
// Any settings that don't work as separate modules
// can go in here as configuration.
_config:{classPrefix:"",enableClasses:!0,enableJSClass:!0,usePrefixes:!0},
// Queue of tests
_q:[],
// Stub these for people who are listening
on:function(e,t){
// I don't really think people should do this, but we can
// safe guard it a bit.
// -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
// This is in case people listen to synchronous tests. I would leave it out,
// but the code to *disallow* sync tests in the real version of this
// function is actually larger than this.
var n=this;setTimeout(function(){t(n[e])},0)},addTest:function(e,t,n){h.push({name:e,fn:t,options:n})},addAsyncTest:function(e){h.push({name:null,fn:e})}},g=function(){};g.prototype=v,
// Leak modernizr globally when you `require` it rather than force it here.
// Overwrite name so constructor name is nicer :D
g=new g;var y,E=[];!function(){var e={}.hasOwnProperty;/* istanbul ignore else */
/* we have no way of testing IE 5.5 or safari 2,
     * so just assume the else gets hit */
y=r(e,"undefined")||r(e.call,"undefined")?function(e,t){/* yes, this can give false positives/negatives, but most of the time we don't care about those */
return t in e&&r(e.constructor.prototype[t],"undefined")}:function(t,n){return e.call(t,n)}}();/**
   * docElement is a convenience wrapper to grab the root element of the document
   *
   * @access private
   * @returns {HTMLElement|SVGElement} The root element of the document
   */
var C=t.documentElement,b="svg"===C.nodeName.toLowerCase();
// _l tracks listeners for async tests, as well as tests that execute after the initial run
v._l={},/**
   * Modernizr.on is a way to listen for the completion of async tests. Being
   * asynchronous, they may not finish before your scripts run. As a result you
   * will get a possibly false negative `undefined` value.
   *
   * @memberof Modernizr
   * @name Modernizr.on
   * @access public
   * @function on
   * @param {string} feature - String name of the feature detect
   * @param {function} cb - Callback function returning a Boolean - true if feature is supported, false if not
   * @example
   *
   * ```js
   * Modernizr.on('flash', function( result ) {
   *   if (result) {
   *    // the browser has flash
   *   } else {
   *     // the browser does not have flash
   *   }
   * });
   * ```
   */
v.on=function(e,t){
// Create the list of listeners if it doesn't exist
this._l[e]||(this._l[e]=[]),
// Push this test on to the listener list
this._l[e].push(t),
// If it's already been resolved, trigger it on next tick
g.hasOwnProperty(e)&&
// Next Tick
setTimeout(function(){g._trigger(e,g[e])},0)},/**
   * _trigger is the private function used to signal test completion and run any
   * callbacks registered through [Modernizr.on](#modernizr-on)
   *
   * @memberof Modernizr
   * @name Modernizr._trigger
   * @access private
   * @function _trigger
   * @param {string} feature - string name of the feature detect
   * @param {function|boolean} [res] - A feature detection function, or the boolean =
   * result of a feature detection function
   */
v._trigger=function(e,t){if(this._l[e]){var n=this._l[e];
// Force async
setTimeout(function(){var e;for(e=0;e<n.length;e++)(0,n[e])(t)},0),
// Don't trigger these again
delete this._l[e]}},
// After all the tests are run, add self to the Modernizr prototype
g._q.push(function(){v.addTest=o});b||function(e,t){/*--------------------------------------------------------------------------*/
/**
       * Creates a style sheet with the given CSS text and adds it to the document.
       * @private
       * @param {Document} ownerDocument The document.
       * @param {String} cssText The CSS text.
       * @returns {StyleSheet} The style element.
       */
function n(e,t){var n=e.createElement("p"),r=e.getElementsByTagName("head")[0]||e.documentElement;return n.innerHTML="x<style>"+t+"</style>",r.insertBefore(n.lastChild,r.firstChild)}/**
       * Returns the value of `html5.elements` as an array.
       * @private
       * @returns {Array} An array of shived element node names.
       */
function r(){var e=g.elements;return"string"==typeof e?e.split(" "):e}/**
       * Returns the data associated to the given document
       * @private
       * @param {Document} ownerDocument The document.
       * @returns {Object} An object of data.
       */
function o(e){var t=v[e[m]];return t||(t={},h++,e[m]=h,v[h]=t),t}/**
       * returns a shived element for the given nodeName and document
       * @memberOf html5
       * @param {String} nodeName name of the element
       * @param {Document} ownerDocument The context document.
       * @returns {Object} The shived element.
       */
function i(e,n,r){if(n||(n=t),c)return n.createElement(e);r||(r=o(n));var i;
// Avoid adding some elements to fragments in IE < 9 because
// * Attributes like `name` or `type` cannot be set/changed once an element
//   is inserted into a document/fragment
// * Link elements with `src` attributes that are inaccessible, as with
//   a 403 response, will cause the tab/window to crash
// * Script elements appended to fragments will execute when their `src`
//   or `text` property is set
return!(i=r.cache[e]?r.cache[e].cloneNode():p.test(e)?(r.cache[e]=r.createElem(e)).cloneNode():r.createElem(e)).canHaveChildren||d.test(e)||i.tagUrn?i:r.frag.appendChild(i)}/*--------------------------------------------------------------------------*/
/**
       * Shivs the given document.
       * @memberOf html5
       * @param {Document} ownerDocument The document to shiv.
       * @returns {Document} The shived document.
       */
function a(e){e||(e=t);var a=o(e);
// corrects block display not defined in IE6/7/8/9
/**
       * Shivs the `createElement` and `createDocumentFragment` methods of the document.
       * @private
       * @param {Document|DocumentFragment} ownerDocument The document.
       * @param {Object} data of the document.
       */
return!g.shivCSS||u||a.hasCSS||(a.hasCSS=!!n(e,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),c||function(e,t){t.cache||(t.cache={},t.createElem=e.createElement,t.createFrag=e.createDocumentFragment,t.frag=t.createFrag()),e.createElement=function(n){
//abort shiv
//abort shiv
return g.shivMethods?i(n,e,t):t.createElem(n)},e.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+
// unroll the `createElement` calls
r().join().replace(/[\w\-:]+/g,function(e){return t.createElem(e),t.frag.createElement(e),'c("'+e+'")'})+");return n}")(g,t.frag)}(e,a),e}/*--------------------------------------------------------------------------*/
/**
       * Wraps all HTML5 elements in the given document with printable elements.
       * (eg. the "header" element is wrapped with the "html5shiv:header" element)
       * @private
       * @param {Document} ownerDocument The document.
       * @returns {Array} An array wrappers added.
       */
function s(e){for(var t,n=e.getElementsByTagName("*"),o=n.length,i=RegExp("^(?:"+r().join("|")+")$","i"),a=[];o--;)t=n[o],i.test(t.nodeName)&&a.push(t.applyElement(/**
       * Creates a printable wrapper for the given element.
       * @private
       * @param {Element} element The element.
       * @returns {Element} The wrapper.
       */
function(e){var t,n=e.attributes,r=n.length,o=e.ownerDocument.createElement(E+":"+e.nodeName);
// copy element attributes to the wrapper
for(;r--;)(t=n[r]).specified&&o.setAttribute(t.nodeName,t.nodeValue);
// copy element styles to the wrapper
return o.style.cssText=e.style.cssText,o}(t)));return a}/*--------------------------------------------------------------------------*/
/**
       * Shivs the given document for print.
       * @memberOf html5
       * @param {Document} ownerDocument The document to shiv.
       * @returns {Document} The shived document.
       */
function l(e){function t(){clearTimeout(l._removeSheetTimer),i&&i.removeNode(!0),i=null}var i,a,l=o(e),u=e.namespaces,c=e.parentWindow;return!C||e.printShived?e:(void 0===u[E]&&u.add(E),c.attachEvent("onbeforeprint",function(){t();
// convert styleSheets collection to an array
for(var o,l,u,c=e.styleSheets,f=[],d=c.length,p=Array(d);d--;)p[d]=c[d];
// concat all style sheet CSS text
for(;u=p.pop();)
// IE does not enforce a same origin policy for external style sheets...
// but has trouble with some dynamically created stylesheets
if(!u.disabled&&y.test(u.media)){try{o=u.imports,l=o.length}catch(e){l=0}for(d=0;d<l;d++)p.push(o[d]);try{f.push(u.cssText)}catch(e){}}
// wrap all HTML5 elements with printable elements and add the shived style sheet
f=/**
       * Shivs the given CSS text.
       * (eg. header{} becomes html5shiv\:header{})
       * @private
       * @param {String} cssText The CSS text to shiv.
       * @returns {String} The shived CSS text.
       */
function(e){for(var t,n=e.split("{"),o=n.length,i=RegExp("(^|[\\s,>+~])("+r().join("|")+")(?=[[\\s,>+~#.:]|$)","gi"),a="$1"+E+"\\:$2";o--;)(t=n[o]=n[o].split("}"))[t.length-1]=t[t.length-1].replace(i,a),n[o]=t.join("}");return n.join("{")}(f.reverse().join("")),a=s(e),i=n(e,f)}),c.attachEvent("onafterprint",function(){
// remove wrappers, leaving the original elements, and remove the shived style sheet
!/**
       * Removes the given wrappers, leaving the original elements.
       * @private
       * @params {Array} wrappers An array of printable wrappers.
       */
function(e){for(var t=e.length;t--;)e[t].removeNode()}(a),clearTimeout(l._removeSheetTimer),l._removeSheetTimer=setTimeout(t,500)}),e.printShived=!0,e)}/** version */
var u,c,f=e.html5||{},d=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,p=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,m="_html5shiv",h=0,v={};!function(){try{var e=t.createElement("a");e.innerHTML="<xyz></xyz>",
//if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
u="hidden"in e,c=1==e.childNodes.length||function(){
// assign a false positive if unable to shiv
t.createElement("a");var e=t.createDocumentFragment();return void 0===e.cloneNode||void 0===e.createDocumentFragment||void 0===e.createElement}()}catch(e){
// assign a false positive if detection fails => unable to shiv
u=!0,c=!0}}();/*--------------------------------------------------------------------------*/
/**
       * The `html5` object is exposed so that more elements can be shived and
       * existing shiving can be detected on iframes.
       * @type Object
       * @example
       *
       * // options can be changed before the script is included
       * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
       */
var g={/**
         * An array or space separated string of node names of the elements to shiv.
         * @memberOf html5
         * @type Array|String
         */
elements:f.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video",/**
         * current version of html5shiv
         */
version:"3.7.3",/**
         * A flag to indicate that the HTML5 style sheet should be inserted.
         * @memberOf html5
         * @type Boolean
         */
shivCSS:!1!==f.shivCSS,/**
         * Is equal to true if a browser supports creating unknown/HTML5 elements
         * @memberOf html5
         * @type boolean
         */
supportsUnknownElements:c,/**
         * A flag to indicate that the document's `createElement` and `createDocumentFragment`
         * methods should be overwritten.
         * @memberOf html5
         * @type Boolean
         */
shivMethods:!1!==f.shivMethods,/**
         * A string to describe the type of `html5` object ("default" or "default print").
         * @memberOf html5
         * @type String
         */
type:"default",
// shivs the document according to the specified `html5` object options
shivDocument:a,
//creates a shived element
createElement:i,
//creates a shived documentFragment
createDocumentFragment:/**
       * returns a shived DocumentFragment for the given document
       * @memberOf html5
       * @param {Document} ownerDocument The context document.
       * @returns {Object} The shived DocumentFragment.
       */
function(e,n){if(e||(e=t),c)return e.createDocumentFragment();for(var i=(n=n||o(e)).frag.cloneNode(),a=0,s=r(),l=s.length;a<l;a++)i.createElement(s[a]);return i},
//extends list of elements
addElements:/**
       * Extends the built-in list of html5 elements
       * @memberOf html5
       * @param {String|Array} newElements whitespace separated list or array of new element names to shiv
       * @param {Document} ownerDocument The context document.
       */
function(e,t){var n=g.elements;"string"!=typeof n&&(n=n.join(" ")),"string"!=typeof e&&(e=e.join(" ")),g.elements=n+" "+e,a(t)}};/*--------------------------------------------------------------------------*/
// expose html5
e.html5=g,
// shiv the document
a(t);/*------------------------------- Print Shiv -------------------------------*/
/** Used to filter media types */
var y=/^$|\b(?:all|print)\b/,E="html5shiv",C=!c&&function(){
// assign a false negative if unable to shiv
var n=t.documentElement;return!(void 0===t.namespaces||void 0===t.parentWindow||void 0===n.applyElement||void 0===n.removeNode||void 0===e.attachEvent)}();/*--------------------------------------------------------------------------*/
// expose API
g.type+=" print",g.shivPrint=l,
// shiv for print
l(t),"object"==typeof module&&module.exports&&(module.exports=g)}(void 0!==e?e:this,t);/**
   * Create our "modernizr" element that we do most feature tests on.
   *
   * @access private
   */
var S={elem:a("modernizr")};
// Clean up this element
g._q.push(function(){delete S.elem});var x={style:S.elem.style};
// kill ref for gc, must happen before mod.elem is removed, so we unshift on to
// the front of the queue.
g._q.unshift(function(){delete x.style});/**
   * testProp() investigates whether a given style property is recognized
   * Property names can be provided in either camelCase or kebab-case.
   *
   * @memberof Modernizr
   * @name Modernizr.testProp
   * @access public
   * @optionName Modernizr.testProp()
   * @optionProp testProp
   * @function testProp
   * @param {string} prop - Name of the CSS property to check
   * @param {string} [value] - Name of the CSS value to check
   * @param {boolean} [useValue] - Whether or not to check the value if @supports isn't supported
   * @returns {boolean}
   * @example
   *
   * Just like [testAllProps](#modernizr-testallprops), only it does not check any vendor prefixed
   * version of the string.
   *
   * Note that the property name must be provided in camelCase (e.g. boxSizing not box-sizing)
   *
   * ```js
   * Modernizr.testProp('pointerEvents')  // true
   * ```
   *
   * You can also provide a value as an optional second argument to check if a
   * specific value is supported
   *
   * ```js
   * Modernizr.testProp('pointerEvents', 'none') // true
   * Modernizr.testProp('pointerEvents', 'penguin') // false
   * ```
   */
v.testProp=function(e,t,r){return f([e],n,t,r)};var _=v._config.usePrefixes?"Moz O ms Webkit".split(" "):[];v._cssomPrefixes=_;/**
   * List of JavaScript DOM values used for tests
   *
   * @memberof Modernizr
   * @name Modernizr._domPrefixes
   * @optionName Modernizr._domPrefixes
   * @optionProp domPrefixes
   * @access public
   * @example
   *
   * Modernizr._domPrefixes is exactly the same as [_prefixes](#modernizr-_prefixes), but rather
   * than kebab-case properties, all properties are their Capitalized variant
   *
   * ```js
   * Modernizr._domPrefixes === [ "Moz", "O", "ms", "Webkit" ];
   * ```
   */
var w=v._config.usePrefixes?"Moz O ms Webkit".toLowerCase().split(" "):[];v._domPrefixes=w,
// Modernizr.testAllProps() investigates whether a given style property,
// or any of its vendor-prefixed variants, is recognized
//
// Note that the property names must be provided in the camelCase variant.
// Modernizr.testAllProps('boxSizing')
v.testAllProps=p,v.testAllProps=m,/*!
{
  "name": "Flexbox",
  "property": "flexbox",
  "caniuse": "flexbox",
  "tags": ["css"],
  "notes": [{
    "name": "The _new_ flexbox",
    "href": "http://dev.w3.org/csswg/css3-flexbox"
  }],
  "warnings": [
    "A `true` result for this detect does not imply that the `flex-wrap` property is supported; see the `flexwrap` detect."
  ]
}
!*/
/* DOC
Detects support for the Flexible Box Layout model, a.k.a. Flexbox, which allows easy manipulation of layout order and sizing within a container.
*/
g.addTest("flexbox",m("flexBasis","1px",!0));/**
   * atRule returns a given CSS property at-rule (eg @keyframes), possibly in
   * some prefixed form, or false, in the case of an unsupported rule
   *
   * @memberof Modernizr
   * @name Modernizr.atRule
   * @optionName Modernizr.atRule()
   * @optionProp atRule
   * @access public
   * @function atRule
   * @param {string} prop - String name of the @-rule to test for
   * @returns {string|boolean} The string representing the (possibly prefixed)
   * valid version of the @-rule, or `false` when it is unsupported.
   * @example
   * ```js
   *  var keyframes = Modernizr.atRule('@keyframes');
   *
   *  if (keyframes) {
   *    // keyframes are supported
   *    // could be `@-webkit-keyframes` or `@keyframes`
   *  } else {
   *    // keyframes === `false`
   *  }
   * ```
   *
   */
var T=function(t){var r,o=prefixes.length,i=e.CSSRule;if(void 0===i)return n;if(!t)return!1;if(
// remove literal @ from beginning of provided property
t=t.replace(/^@/,""),(
// CSSRules use underscores instead of dashes
r=t.replace(/-/g,"_").toUpperCase()+"_RULE")in i)return"@"+t;for(var a=0;a<o;a++){
// prefixes gives us something like -o-, and we want O_
var s=prefixes[a];if(s.toUpperCase()+"_"+r in i)return"@-"+s.toLowerCase()+"-"+t}return!1};v.atRule=T;/**
   * prefixed returns the prefixed or nonprefixed property name variant of your input
   *
   * @memberof Modernizr
   * @name Modernizr.prefixed
   * @optionName Modernizr.prefixed()
   * @optionProp prefixed
   * @access public
   * @function prefixed
   * @param {string} prop - String name of the property to test for
   * @param {object} [obj] - An object to test for the prefixed properties on
   * @param {HTMLElement} [elem] - An element used to test specific properties against
   * @returns {string|false} The string representing the (possibly prefixed) valid
   * version of the property, or `false` when it is unsupported.
   * @example
   *
   * Modernizr.prefixed takes a string css value in the DOM style camelCase (as
   * opposed to the css style kebab-case) form and returns the (possibly prefixed)
   * version of that property that the browser actually supports.
   *
   * For example, in older Firefox...
   * ```js
   * prefixed('boxSizing')
   * ```
   * returns 'MozBoxSizing'
   *
   * In newer Firefox, as well as any other browser that support the unprefixed
   * version would simply return `boxSizing`. Any browser that does not support
   * the property at all, it will return `false`.
   *
   * By default, prefixed is checked against a DOM element. If you want to check
   * for a property on another object, just pass it as a second argument
   *
   * ```js
   * var rAF = prefixed('requestAnimationFrame', window);
   *
   * raf(function() {
   *  renderFunction();
   * })
   * ```
   *
   * Note that this will return _the actual function_ - not the name of the function.
   * If you need the actual name of the property, pass in `false` as a third argument
   *
   * ```js
   * var rAFProp = prefixed('requestAnimationFrame', window, false);
   *
   * rafProp === 'WebkitRequestAnimationFrame' // in older webkit
   * ```
   *
   * One common use case for prefixed is if you're trying to determine which transition
   * end event to bind to, you might do something like...
   * ```js
   * var transEndEventNames = {
   *     'WebkitTransition' : 'webkitTransitionEnd', * Saf 6, Android Browser
   *     'MozTransition'    : 'transitionend',       * only for FF < 15
   *     'transition'       : 'transitionend'        * IE10, Opera, Chrome, FF 15+, Saf 7+
   * };
   *
   * var transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];
   * ```
   *
   * If you want a similar lookup, but in kebab-case, you can use [prefixedCSS](#modernizr-prefixedcss).
   */
var j=v.prefixed=function(e,t,n){
// Convert kebab-case to camelCase
return 0===e.indexOf("@")?T(e):(-1!=e.indexOf("-")&&(e=c(e)),t?p(e,t,n):p(e,"pfx"))};/*!
{
  "name": "CSS Object Fit",
  "caniuse": "object-fit",
  "property": "objectfit",
  "tags": ["css"],
  "builderAliases": ["css_objectfit"],
  "notes": [{
    "name": "Opera Article on Object Fit",
    "href": "https://dev.opera.com/articles/css3-object-fit-object-position/"
  }]
}
!*/
g.addTest("objectfit",!!j("objectFit"),{aliases:["object-fit"]}),
// Run each test
/**
   * Run through all tests and detect their support in the current UA.
   *
   * @access private
   */
function(){var e,t,n,o,i,a;for(var s in h)if(h.hasOwnProperty(s)){
// run the test, throw the return value into the Modernizr,
// then based on that boolean, define an appropriate className
// and push it into an array of classes we'll join later.
//
// If there is no name, it's an 'async' test that is run,
// but not directly added to the object. That should
// be done with a post-run addTest call.
if(e=[],(t=h[s]).name&&(e.push(t.name.toLowerCase()),t.options&&t.options.aliases&&t.options.aliases.length))
// Add all the aliases into the names list
for(n=0;n<t.options.aliases.length;n++)e.push(t.options.aliases[n].toLowerCase());
// Set each of the names on the Modernizr object
for(
// Run the test, or use the raw value if it's not a function
o=r(t.fn,"function")?t.fn():t.fn,i=0;i<e.length;i++)1===(
// Support dot properties as sub tests. We don't do checking to make sure
// that the implied parent tests have been added. You must call them in
// order (either in the test, or make the parent test a dependency).
//
// Cap it to TWO to make the logic simple and because who needs that kind of subtesting
// hashtag famous last words
a=e[i].split(".")).length?g[a[0]]=o:(
// cast to a Boolean, if not one already
!g[a[0]]||g[a[0]]instanceof Boolean||(g[a[0]]=new Boolean(g[a[0]])),g[a[0]][a[1]]=o),E.push((o?"":"no-")+a.join("-"))}}(),delete v.addTest,delete v.addAsyncTest;
// Run the things that are supposed to run after the tests
for(var N=0;N<g._q.length;N++)g._q[N]();
// Leak Modernizr namespace
e.Modernizr=g}(window,document);